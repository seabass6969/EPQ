
@online{macleod_abracadabra_nodate,
	title = {abracadabra: How does Shazam work? - Cameron {MacLeod}},
	url = {https://www.cameronmacleod.com/blog/how-does-shazam-work},
	shorttitle = {abracadabra},
	author = {{MacLeod}, Cameron},
	urldate = {2024-10-28},
	langid = {english},
	file = {Snapshot:/home/cephas/Zotero/storage/LYURUIEI/how-does-shazam-work.html:text/html},
}

@article{wang_industrial-strength_2003,
	title = {An Industrial-Strength Audio Search Algorithm},
	author = {Wang, Avery Li-Chun},
	date = {2003-01},
	langid = {english},
	file = {PDF:/home/cephas/Zotero/storage/RQ6E6ET6/Wang - An Industrial-Strength Audio Search Algorithm.pdf:application/pdf},
}

@article{virtanen_scipy_2020,
	title = {{SciPy} 1.0: fundamental algorithms for scientific computing in Python},
	volume = {17},
	rights = {2020 The Author(s)},
	issn = {1548-7105},
	url = {https://www.nature.com/articles/s41592-019-0686-2},
	doi = {10.1038/s41592-019-0686-2},
	shorttitle = {{SciPy} 1.0},
	abstract = {{SciPy} is an open-source scientific computing library for the Python programming language. Since its initial release in 2001, {SciPy} has become a de facto standard for leveraging scientific algorithms in Python, with over 600 unique code contributors, thousands of dependent packages, over 100,000 dependent repositories and millions of downloads per year. In this work, we provide an overview of the capabilities and development practices of {SciPy} 1.0 and highlight some recent technical developments.},
	pages = {261--272},
	number = {3},
	journaltitle = {Nature Methods},
	shortjournal = {Nat Methods},
	author = {Virtanen, Pauli and Gommers, Ralf and Oliphant, Travis E. and Haberland, Matt and Reddy, Tyler and Cournapeau, David and Burovski, Evgeni and Peterson, Pearu and Weckesser, Warren and Bright, Jonathan and van der Walt, Stéfan J. and Brett, Matthew and Wilson, Joshua and Millman, K. Jarrod and Mayorov, Nikolay and Nelson, Andrew R. J. and Jones, Eric and Kern, Robert and Larson, Eric and Carey, C. J. and Polat, İlhan and Feng, Yu and Moore, Eric W. and {VanderPlas}, Jake and Laxalde, Denis and Perktold, Josef and Cimrman, Robert and Henriksen, Ian and Quintero, E. A. and Harris, Charles R. and Archibald, Anne M. and Ribeiro, Antônio H. and Pedregosa, Fabian and van Mulbregt, Paul},
	urldate = {2024-10-28},
	date = {2020-03},
	langid = {english},
	note = {Publisher: Nature Publishing Group},
	keywords = {Biophysical chemistry, Computational biology and bioinformatics, Technology},
	file = {Full Text PDF:/home/cephas/Zotero/storage/2GQXKBNK/Virtanen et al. - 2020 - SciPy 1.0 fundamental algorithms for scientific computing in Python.pdf:application/pdf},
}

@article{hunter_matplotlib_2007,
	title = {Matplotlib: A 2D graphics environment},
	volume = {9},
	doi = {10.1109/MCSE.2007.55},
	pages = {90--95},
	number = {3},
	journaltitle = {Computing in Science \& Engineering},
	author = {Hunter, John D.},
	date = {2007},
}

@inreference{noauthor_eulers_2024,
	title = {Euler's formula},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Euler%27s_formula&oldid=1247828798},
	booktitle = {Wikipedia},
	urldate = {2024-11-07},
	date = {2024-09-26},
	langid = {english},
	note = {Page Version {ID}: 1247828798},
	file = {PDF:/home/cephas/Zotero/storage/IJIXCBWC/2024 - Euler's formula.pdf:application/pdf;Snapshot:/home/cephas/Zotero/storage/UTDLGEQL/Euler's_formula.html:text/html},
}

@software{mcfee_librosalibrosa_2024,
	title = {librosa/librosa: 0.10.2.post1},
	rights = {{ISC} License},
	url = {https://zenodo.org/doi/10.5281/zenodo.591533},
	shorttitle = {librosa/librosa},
	abstract = {What's Changed



Bump minimum matplotlib to 3.5.0 by @bmcfee in https://github.com/librosa/librosa/pull/1839


Full Changelog: https://github.com/librosa/librosa/compare/0.10.2...0.10.2.post1},
	version = {0.10.2.post1},
	publisher = {Zenodo},
	author = {{McFee}, Brian and Matt {McVicar} and Daniel Faronbi and Iran Roman and Matan Gover and Stefan Balke and Scott Seyfarth and Ayoub Malek and Colin Raffel and Vincent Lostanlen and Benjamin van Niekirk and Dana Lee and Frank Cwitkowitz and Frank Zalkow and Oriol Nieto and Dan Ellis and Jack Mason and Kyungyun Lee and Bea Steers and Emily Halvachs and Carl Thomé and Fabian Robert-Stöter and Rachel Bittner and Ziyao Wei and Adam Weiss and Eric Battenberg and Keunwoo Choi and Ryuichi Yamamoto and {CJ} Carr and Alex Metsai and Stefan Sullivan and Pius Friesch and Asmitha Krishnakumar and Shunsuke Hidaka and Steve Kowalik and Fabian Keller and Dan Mazur and Alexandre Chabot-Leclerc and Curtis Hawthorne and Chandrashekhar Ramaprasad and Myungchul Keum and Juanita Gomez and Will Monroe and Viktor Andreevitch Morozov and Kian Eliasi and nullmightybofo and Paul Biberstein and N. Dorukhan Sergin and Romain Hennequin and Rimvydas Naktinis and beantowel and Taewoon Kim and Jon Petter Åsen and Joon Lim and Alex Malins and Darío Hereñú and Stef van der Struijk and Lorenz Nickel and Jackie Wu and Zhen Wang and Tim Gates and Matt Vollrath and Andy Sarroff and Xiao-Ming and Alastair Porter and Seth Kranzler and Voodoohop and Mattia Di Gangi and Helmi Jinoz and Connor Guerrero and Abduttayyeb Mazhar and toddrme2178 and Zvi Baratz and Anton Kostin and Xinlu Zhuang and Cash {TingHin} Lo and Pavel Campr and Eric Semeniuc and Monsij Biswal and Shayenne Moura and Paul Brossier and Hojin Lee and Waldir Pimenta},
	urldate = {2024-11-07},
	date = {2024-05-14},
	doi = {10.5281/ZENODO.591533},
}

@patent{wang_systems_2013,
	title = {Systems and methods for recognizing sound and music signals in high noise and distortion},
	url = {https://patents.google.com/patent/US8386258B2/en?assignee=Shazam+Investments+Ltd&num=25},
	holder = {Shazam Investments Ltd},
	type = {patentus},
	number = {8386258B2},
	author = {Wang, Avery Li-Chun and {III}, Julius O. Smith},
	urldate = {2024-12-25},
	date = {2013-02-26},
	langid = {english},
	keywords = {buffer, content, media, media samples, segment},
	file = {Full Text PDF:/home/cephas/Zotero/storage/GBCEPAGL/Wang and III - 2013 - Systems and methods for recognizing sound and music signals in high noise and distortion.pdf:application/pdf},
}

@software{ffmpeg_developers_ffmpeg_nodate,
	title = {ffmpeg: A complete, cross-platform solution to record, convert and stream audio and video},
	rights = {{GNU} Lesser General Public License ({LGPL}) version 2.1 or later},
	url = {https://www.ffmpeg.org/},
	shorttitle = {{FFmpeg}},
	version = {n7.1},
	author = {{FFmpeg developers}},
}

@article{harris_array_2020,
	title = {Array programming with {NumPy}},
	volume = {585},
	issn = {0028-0836, 1476-4687},
	url = {https://www.nature.com/articles/s41586-020-2649-2},
	doi = {10.1038/s41586-020-2649-2},
	abstract = {Abstract
            
              Array programming provides a powerful, compact and expressive syntax for accessing, manipulating and operating on data in vectors, matrices and higher-dimensional arrays. {NumPy} is the primary array programming library for the Python language. It has an essential role in research analysis pipelines in fields as diverse as physics, chemistry, astronomy, geoscience, biology, psychology, materials science, engineering, finance and economics. For example, in astronomy, {NumPy} was an important part of the software stack used in the discovery of gravitational waves
              1
              and in the first imaging of a black hole
              2
              . Here we review how a few fundamental array concepts lead to a simple and powerful programming paradigm for organizing, exploring and analysing scientific data. {NumPy} is the foundation upon which the scientific Python ecosystem is constructed. It is so pervasive that several projects, targeting audiences with specialized needs, have developed their own {NumPy}-like interfaces and array objects. Owing to its central position in the ecosystem, {NumPy} increasingly acts as an interoperability layer between such array computation libraries and, together with its application programming interface ({API}), provides a flexible framework to support the next decade of scientific and industrial analysis.},
	pages = {357--362},
	number = {7825},
	journaltitle = {Nature},
	shortjournal = {Nature},
	author = {Harris, Charles R. and Millman, K. Jarrod and Van Der Walt, Stéfan J. and Gommers, Ralf and Virtanen, Pauli and Cournapeau, David and Wieser, Eric and Taylor, Julian and Berg, Sebastian and Smith, Nathaniel J. and Kern, Robert and Picus, Matti and Hoyer, Stephan and Van Kerkwijk, Marten H. and Brett, Matthew and Haldane, Allan and Del Río, Jaime Fernández and Wiebe, Mark and Peterson, Pearu and Gérard-Marchant, Pierre and Sheppard, Kevin and Reddy, Tyler and Weckesser, Warren and Abbasi, Hameer and Gohlke, Christoph and Oliphant, Travis E.},
	urldate = {2025-01-12},
	date = {2020-09-17},
	langid = {english},
	file = {Full Text:/home/cephas/Zotero/storage/ZRJUZX3D/Harris et al. - 2020 - Array programming with NumPy.pdf:application/pdf},
}

@inproceedings{miller_audio_2002,
	location = {St.Thomas, {VI}, {USA}},
	title = {Audio fingerprinting: nearest neighbor search in high dimensional binary spaces},
	isbn = {978-0-7803-7713-4},
	url = {http://ieeexplore.ieee.org/document/1203277/},
	doi = {10.1109/MMSP.2002.1203277},
	shorttitle = {Audio fingerprinting},
	eventtitle = {2002 {IEEE} 5th Workshop on Multimedia Signal Processing},
	pages = {182--185},
	booktitle = {2002 {IEEE} Workshop on Multimedia Signal Processing.},
	publisher = {{IEEE}},
	author = {Miller, M.L. and Rodriguez, M.A. and Cox, I.J.},
	urldate = {2025-01-15},
	date = {2002},
	file = {PDF:/home/cephas/Zotero/storage/ICYYNE53/Miller et al. - 2002 - Audio fingerprinting nearest neighbor search in high dimensional binary spaces.pdf:application/pdf},
}

@inreference{noauthor_hash_2024,
	title = {Hash function},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://simple.wikipedia.org/w/index.php?title=Hash_function&oldid=9718140},
	abstract = {A Hash function is a set of things to do to make an output that is always the same length from some other input data. Hash functions can be used to tell a computer that two things are the same without sending the things twice. Hash functions use all the data they can to change the output. The input can be only a little bit different, and have a totally different output. When a hash function is made, care is taken to make sure two different inputs do not get the same hash value (this is called a hash collision).
A cryptographic hash function is a kind of hash function that is used in cryptography. It is made to make it hard to make two files with the same hash even if you try. It may also be called a 'message digest', 'digital fingerprint', 'digest' or 'checksum'.},
	booktitle = {Simple English Wikipedia, the free encyclopedia},
	urldate = {2025-01-30},
	date = {2024-08-22},
	langid = {english},
	note = {Page Version {ID}: 9718140},
	file = {Snapshot:/home/cephas/Zotero/storage/FYRZH586/Hash_function.html:text/html},
}

@inreference{noauthor_distributed_2024,
	title = {Distributed computing},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Distributed_computing&oldid=1266361966#cite_note-tanenbaum-1},
	abstract = {Distributed computing is a field of computer science that studies distributed systems, defined as computer systems whose inter-communicating components are located on different networked computers. 
The components of a distributed system communicate and coordinate their actions by passing messages to one another in order to achieve a common goal. Three significant challenges of distributed systems are: maintaining concurrency of components, overcoming the lack of a global clock, and managing the independent failure of components. When a component of one system fails, the entire system does not fail. Examples of distributed systems vary from {SOA}-based systems to microservices to massively multiplayer online games to peer-to-peer applications. Distributed systems cost significantly more than monolithic architectures, primarily due to increased needs for additional hardware, servers, gateways, firewalls, new subnets, proxies, and so on. Also, distributed systems are prone to fallacies of distributed computing. On the other hand, a well designed distributed system is more scalable, more durable, more changeable and more fine-tuned than a monolithic application deployed on a single machine. According to Marc Brooker: "a system is scalable in the range where marginal cost of additional workload is nearly constant." Serverless technologies fit this definition but the total cost of ownership, and not just the infra cost must be considered.
A computer program that runs within a distributed system is called  a distributed program, and distributed programming is the process of writing such programs. There are many different types of implementations for the message passing mechanism, including pure {HTTP}, {RPC}-like connectors and message queues.
Distributed computing also refers to the use of distributed systems to solve computational problems. In distributed computing, a problem is divided into many tasks, each of which is solved by one or more computers, which communicate with each other via message passing.},
	booktitle = {Wikipedia},
	urldate = {2025-01-23},
	date = {2024-12-31},
	langid = {english},
	note = {Page Version {ID}: 1266361966},
	file = {Snapshot:/home/cephas/Zotero/storage/LWM3NGLI/Distributed_computing.html:text/html},
}

@inproceedings{ghias_query_1995,
	location = {San Francisco, California, United States},
	title = {Query by humming: musical information retrieval in an audio database},
	isbn = {978-0-89791-751-3},
	url = {http://portal.acm.org/citation.cfm?doid=217279.215273},
	doi = {10.1145/217279.215273},
	shorttitle = {Query by humming},
	eventtitle = {the third {ACM} international conference},
	pages = {231--236},
	booktitle = {Proceedings of the third {ACM} international conference on Multimedia  - {MULTIMEDIA} '95},
	publisher = {{ACM} Press},
	author = {Ghias, Asif and Logan, Jonathan and Chamberlin, David and Smith, Brian C.},
	urldate = {2025-01-31},
	date = {1995},
	langid = {english},
}

@online{amandaghassaei_what_nodate,
	title = {What Is {MIDI}?},
	url = {https://www.instructables.com/What-is-MIDI/},
	abstract = {What Is {MIDI}?: {MIDI} (Musical Instrument Digital Interface) is a protocol developed in the 1980's which allows electronic instruments and other digital musical tools to communicate with each other.\&nbsp; {MIDI} itself does not make sound, it is just a series of messa…},
	titleaddon = {Instructables},
	author = {{amandaghassaei}},
	urldate = {2025-01-31},
	langid = {english},
	file = {Snapshot:/home/cephas/Zotero/storage/9XFUB2WC/What-is-MIDI.html:text/html},
}

@online{newnham_interview_2023,
	title = {{INTERVIEW}: Dr Avery Wang, Principal Research Scientist at Apple and Co-Founder and Chief Scientist…},
	url = {https://daniellenewnham.medium.com/fostering-innovation-and-choosing-the-right-founding-team-6287f7eed9f},
	shorttitle = {{INTERVIEW}},
	abstract = {The story of Shazam is a remarkable one.},
	titleaddon = {Medium},
	author = {Newnham, Danielle},
	urldate = {2025-02-02},
	date = {2023-02-02},
	langid = {english},
	file = {Snapshot:/home/cephas/Zotero/storage/MCVEGSHD/fostering-innovation-and-choosing-the-right-founding-team-6287f7eed9f.html:text/html},
}

@report{yang_music_2001,
	title = {Music Database Retrieval Based on Spectral Similarity},
	url = {http://ilpubs.stanford.edu:8090/489/},
	abstract = {We present an efficient algorithm to retrieve similar music pieces from an audio database. The algorithm tries to capture the intuitive notion of similarity perceived by human: two pieces are similar if they are fully or partially based on the same score, even if they are performed by different people or at different speed. Each audio file is pre-processed to identify local peaks in signal power. A spectral vector is extracted near each peak, and a list of such spectral vectors forms our intermediate representation of a music piece. A database of such intermediate representations is constructed, and two pieces are matched against each other based on a specially-defined distance function. Matching results are then filtered according to some linearity criteria to select the best result to a user query.},
	number = {2001-14},
	institution = {Stanford},
	type = {Technical Report},
	author = {Yang, Cheng},
	date = {2001},
	note = {Backup Publisher: Stanford {InfoLab}},
	keywords = {content-based music retrieval, dynamic programming matching, linearity filtering., raw audio, spectral similarity},
	file = {PDF:/home/cephas/Zotero/storage/EUN9XN2P/Yang - Music Database Retrieval Based on Spectral Similarity.pdf:application/pdf;PDF:/home/cephas/Zotero/storage/MWVGLTUB/Yang - Music Database Retrieval Based on Spectral Similarity.pdf:application/pdf},
}

@inreference{noauthor_fast_2025,
	title = {Fast Fourier transform},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=Fast_Fourier_transform&oldid=1273240384},
	abstract = {A fast Fourier transform ({FFT}) is an algorithm that computes the discrete Fourier transform ({DFT}) of a sequence, or its inverse ({IDFT}). A Fourier transform converts a signal from its original domain (often time or space) to a representation in the frequency domain and vice versa. The {DFT} is obtained by decomposing a sequence of values into components of different frequencies. This operation is useful in many fields, but computing it directly from the definition is often too slow to be practical. An {FFT} rapidly computes such transformations by factorizing the {DFT} matrix into a product of sparse (mostly zero) factors. As a result, it manages to reduce the complexity of computing the {DFT} from 
  
    
      
        O
        (
        
          n
          
            2
          
        
        )
      
    
    \{{\textbackslash}textstyle O(n{\textasciicircum}\{2\})\}
  
, which arises if one simply applies the definition of {DFT}, to 
  
    
      
        O
        (
        n
        log
        ⁡
        n
        )
      
    
    \{{\textbackslash}textstyle O(n{\textbackslash}log n)\}
  
, where n is the data size. The difference in speed can be enormous, especially for long data sets where n may be in the thousands or millions. In the presence of round-off error, many {FFT} algorithms are much more accurate than evaluating the {DFT} definition directly or indirectly. There are many different {FFT} algorithms based on a wide range of published theories, from simple complex-number arithmetic to group theory and number theory.

Fast Fourier transforms are widely used for applications in engineering, music, science, and mathematics. The basic ideas were popularized in 1965, but some algorithms had been derived as early as 1805. In 1994, Gilbert Strang described the {FFT} as "the most important numerical algorithm of our lifetime", and it was included in Top 10 Algorithms of 20th Century by the {IEEE} magazine Computing in Science \& Engineering.
The best-known {FFT} algorithms depend upon the factorization of n, but there are {FFTs} with 
  
    
      
        O
        (
        n
        log
        ⁡
        n
        )
      
    
    \{{\textbackslash}displaystyle O(n{\textbackslash}log n)\}
  
 complexity for all, even prime, n. Many {FFT} algorithms depend only on the fact that 
  
    
      
        
          e
          
            −
            2
            π
            i
            
              /
            
            n
          
        
      
    
    \{{\textbackslash}textstyle e{\textasciicircum}\{-2{\textbackslash}pi i/n\}\}
  
 is an n'th primitive root of unity, and thus can be applied to analogous transforms over any finite field, such as number-theoretic transforms. Since the inverse {DFT} is the same as the {DFT}, but with the opposite sign in the exponent and a 1/n factor, any {FFT} algorithm can easily be adapted for it.},
	booktitle = {Wikipedia},
	urldate = {2025-02-06},
	date = {2025-02-01},
	langid = {english},
	note = {Page Version {ID}: 1273240384},
	file = {Snapshot:/home/cephas/Zotero/storage/YDYEZ5QL/Fast_Fourier_transform.html:text/html},
}
